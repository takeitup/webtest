web聊天室UML建模
一．建模准备
1.建模简介
软件系统的开发过程通常会被划分成一些步骤，每个步骤会用到不同的UML图。由于建模系统变得越来越复杂，一致性问题就越发突出起来。而在其中，有两种类型或问题更为显著。第一，内部一致性问题，涉及给定模型内部制品之间的一致性。第二，系统之间一致性问题，涉及软件开发过程中不同演化模型之间的一致性。我们主要关注于内部一致性问题。
2.通信协议
我们将要创建的聊天室程序是按照客户机/服务器范型来架构的。客户会随机连接聊天室。如果某个聊天室接收了客户，客户就会发送消息给这个聊天室。然后聊天室广播每条消息，除了发送者以外，每个与聊天室建立连接的客户都会收到一份拷贝。
用例示例：
（1）系统包括五个客户和两个聊天室。客户端最初没有连接。
（2）一个聊天室至多接收三个客户。当且仅当容量没有超标时聊天室才会接收连接。
（3）发出请求的客户会立刻收到接收或拒绝通知。
（4）在客户可以发送聊天信息之前必须被一个聊天室接收。
（5）连接建立之后，客户会每隔一到五秒（非均匀分布）给它所连接的聊天室发送随机消息。聊天室会立即接收消息，它将耗时一秒钟来处理接收到的消息，并把它广播给除发送者之外的所有连接客户。
二．建模过程
1.类的设计
我们需要两个类：Client和ChatRoom。仿真开始时，会初始化五个Client实例和两个ChatRoom实例。我们还加入了一个singleton类：Manager。Manager以仲裁者的身份中继组件之间的所有通信。这种中央控制措施将会帮助截取系统传递的所有消息，使用它们就可以检查模型的正确性。
（1）ChatRoom类：ChatRoom提供两个方法处理到达的事件。request处理来到的请求，每个请求都有参数clientID和roomID。ChatRoom把接收或拒绝通知发回拥有全局ID标识clientID的发送者。它也使用参数roomID来决定请求是发给它自己还是发给另外一个聊天室了1。send方法接收由客户clientID发送的消息msg。这条msg将会在一秒钟之后被广播出去。
（2）Client类：Client的方法accept和reject处理到达的接收和拒绝通知。参数clientID用来确定目标客户。当一个Client接收到一个broadcast事件，它会检查自己是否在clients集合中。如果情况确实如此，消息msg就会在输出中被打印出来。
（3）Manager类：Manager中继连接请求、接收和拒绝通知、来自客户的消息以及聊天室的广播。例如，如果它收到来自聊天室的广播，有三个参数会告诉它消息最初的发送者（客户），广播者（聊天室）以及消息字符串。然后它把消息发给所有连接在聊天室中的，除了最初发送者以外的客户。
2.时序图
时序图中包括如下元素：角色，对象，生命线，激活期和消息。
角色（Actor）：系统角色，可以是人或者其他系统，子系统。
对象(Object)：对象代表时序图中的对象在交互中所扮演的角色，位于时序图顶部和对象代表。
生命线(Lifeline)：生命线代表时序图中的对象在一段时期内的存在。时序图中每个对象和底部中心都有一条垂直的虚线，这就是对象的生命线，对象间 的消息存在于两条虚线间。
激活期(Activation)：激活期代表时序图中的对象执行一项操作的时期，在时序图中每条生命线上的窄的矩形代表活动期。
消息(Message)：消息是定义交互和协作中交换信息的类，用于对实体间的通信内容建模，信息用于在实体间传递信息。
（1）请求和消息模式
Client首先会调用Manager的方法mrequest。然后Manager通过调用ChatRoom的方法request中继这个调用。ChatRoom立刻响应，回调Manager的方法maccept或mreject。然后请求Client会接收到由Manager中继的响应。
（2）类图和协议之间的一致性问题
与类图之间的一致性是容易检查的，可以通过收集组件接收到的所有方法调用来达成。在请求模式中，Manager接收mrequest、maccept和mreject。在消息模式中，它接收msend和mbroadcast。由于时序图中并没有给出参数，那样就没有检查参数的必要。
注意基本的时序图无法表达某个时间或某个阶段不应该发生的事情。一种可能的设计错误是时序图的语义。例如，在请求模式中，时序图描述：如果客户发送mrequest，管理器没有时间前置地发送request，聊天室发送maccept或mreject，也没有时间前置，然后管理器发送accept或reject。不幸地是，迟钝的客户不会发送任何请求，这显然是系统当中的一个问题，不能通过检查时序图检测出来。最坏的情况是根本没有客户连接，这样系统就会永远停机。
3.状态图
（1）SVM（状态虚拟机）约定
想要轻松理解状态图设计，就必须先了解SVM的一些约定。
尽管最初的状态图并不是模块化的，但仍然可以使用SVM实现基于组件的设计。对于聊天室模型来说这是必需的，象客户和聊天室这样的组件可以独立进行设计，但最终在系统中还是要一起工作的。组件通过导入可以进行复用。较大的组件导入一些小的组件（实例），作为它的一个状态。
SVM模型用文本文件编写。宏是在SVM中引入的一个概念。宏在SVM源文件里的MACRO节中定义。一旦定义后，在整个文本文件中就可以括在括号中使用。
组件被导入的时候宏也可以充当参数。进行导入的组件要重新定义一部分或所有最初在被导入组件中定义的宏，也包括预定义宏。
（2）扩展状态图形式体系中的聊天室模型
Client、ChatRoom和Manager组件分别在独立的状态图中设计。同一类型的每个实例都有一个惟一的ID参数。由于可接收的事件集合是不相交的，因此不同类型的实例就可以拥有相同的ID。这个模型可以在SVM环境中仿真或执行。
Client组件：最初，它处在nochat状态。每隔一到三秒（非均匀分布）会触发一次mrequest事件，通过管理器来重复连接聊天室，直到请求被接收为止。uniform是一个Python函数，它返回某个区间内的随机实数值，randint返回随机整数值。事件的第一个参数给出客户的惟一ID。第二个参数给出目的聊天室（随机从1或2中选取）。然后，客户转移到状态connected，开始发送消息和接收广播。事件参数是作为列表发送的，[PARAM][0]访问第一个参数，依次类推。
ChatRoom组件：它使用列表messages[ID]把到来的消息进行排队。这就意味着每一个有着惟一ID的聊天室都会有其自己的队列。如果当它正在处理前面的消息时（要耗时一秒钟），一条消息到达，新到达的消息就会加入列表之中。收到消息时的时间也被记录下来，这样即使消息进行排队，它的处理时间自到达时开始计算仍为一秒钟
Manager组件：在聊天室接收客户时，函数rec_comm(client, room)在一个列表中记录连接信息。get_clients(room, client)查询列表并返回聊天室room中除了client以外的所有客户。get_room(client)返回client的房间ID号。
（3）与类图之间的一致性
自动检查所有方法调用的发送者-接收者之间的一致性，这样的程序可以写出来。而不是要编写如何在代码级由类型检查器和/或链接器来检查一致性。譬如，Manager接收事件maccept。这意味着它在类定义中提供方法maccept。在处理事件的状态转换输出和监视哨中，要用到[PARAMS][0]和[PARAMS][1]，这样它就至少需要两个参数。检查器遍历整个Chat模型，找出仅由ChatRoom组件调用（异步地）的方法。
4.一致性检查
（1）输出迹
宏[DUMP(msg)]用来在文件中记录消息msg，一直到执行结束为止（或者自动，或者由调试器手动控制）。每条消息包括三个部分：时间tuple(t, s)，有着惟一ID的发送者或接收者，和消息体。
（2）与时序图的一致性
与时序图的一致性可以通过一套基于规则的方法检查。这些规则在文本文件中定义。检查程序读取文件，检查输出迹是否可以满足所有的规则。正则表达式被扩展之后用以描述规则。规则由四部分组成：前置条件、后置条件、监视哨和计数规则属性。前置条件是正则表达式，用来匹配部分输出迹。它与监视哨结合，定义何时可以使用规则。当规则可用，并且计数规则属性为false时，后置条件必须要在输出迹中找到；如果计数规则属性为true，后置条件一定不可满足。
（3）与协议的一致性
验证模型与协议完全一致如果说是并非不可能的话，至少也是极为困难的。把协议的完整含义转化为程序易于处理的形式化表达是非常困难的。协议中含有的明显事实和常识常常会丢失。作为人与程序之间的接口，自然语言处理技术是有必要的。
三．建模结果
1.时序图与类图间的一致性得到了检查。检查程序验证所有的必需方法在接口中都已正确地确定下来。
2.状态图与类图间的一致性也可按照同样的方法检查。事件的发送者总能为接收者提供足够的参数。
3.状态图与时序图间的一致性使用基于规则的检查程序来检查。正则表达式被扩展用来确定前置条件、后置条件、监视哨和计数规则属性。
4.类图与协议（初始需求）之间的一致性没有检查。
5.时序图与协议之间的一致性仅仅做了手工检查。
6.检查扩展状态图中的最终设计和协议之间的一致性，要更为困难。
